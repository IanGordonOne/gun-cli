{"id":"../node_modules/graphql-anywhere/lib/src/getFromAST.js","dependencies":[{"name":"C:\\Users\\shadow\\projects\\open-source\\gun-cli\\node_modules\\graphql-anywhere\\lib\\src\\getFromAST.js.map","includedInParent":true,"mtime":1603029498220},{"name":"C:\\Users\\shadow\\projects\\open-source\\gun-cli\\node_modules\\graphql-anywhere\\src\\getFromAST.ts","includedInParent":true,"mtime":1603029498220},{"name":"C:\\Users\\shadow\\projects\\open-source\\gun-cli\\package.json","includedInParent":true,"mtime":1607332937128},{"name":"C:\\Users\\shadow\\projects\\open-source\\gun-cli\\node_modules\\graphql-anywhere\\package.json","includedInParent":true,"mtime":1603029498220}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction checkDocument(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    var numOpDefinitions = doc.definitions.filter(function (definition) {\n        return definition.kind === 'OperationDefinition';\n    }).length;\n    if (numOpDefinitions > 1) {\n        throw new Error('Queries must have exactly one operation definition.');\n    }\n}\nfunction getFragmentDefinitions(doc) {\n    var fragmentDefinitions = doc.definitions.filter(function (definition) {\n        if (definition.kind === 'FragmentDefinition') {\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n    return fragmentDefinitions;\n}\nexports.getFragmentDefinitions = getFragmentDefinitions;\nfunction createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nexports.createFragmentMap = createFragmentMap;\nfunction getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\nexports.getMainDefinition = getMainDefinition;\n"},"sourceMaps":{"js":{"version":3,"file":"getFromAST.js","sourceRoot":"","sources":["../../src/getFromAST.ts"],"names":[],"mappings":";;AAOA,uBAAuB,GAAiB;IACtC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC;QAC5B,MAAM,IAAI,KAAK,CAAC,0JAC2D,CAAC,CAAC;IAC/E,CAAC;IAED,IAAM,gBAAgB,GAAG,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,UAAC,UAAU;QACzD,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,qBAAqB,CAAC;IACnD,CAAC,CAAC,CAAC,MAAM,CAAC;IAGV,EAAE,CAAC,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;QACzB,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;IACzE,CAAC;AACH,CAAC;AAGD,gCAAuC,GAAiB;IACtD,IAAI,mBAAmB,GAA6B,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,UAAC,UAAU;QACpF,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,oBAAoB,CAAC,CAAC,CAAC;YAC7C,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;IACH,CAAC,CAA6B,CAAC;IAE/B,MAAM,CAAC,mBAAmB,CAAC;AAC7B,CAAC;AAVD,wDAUC;AAQD,2BAAkC,SAAwC;IAAxC,0BAAA,EAAA,cAAwC;IACxE,IAAM,QAAQ,GAAgB,EAAE,CAAC;IACjC,SAAS,CAAC,OAAO,CAAC,UAAC,QAAQ;QACzB,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;IAC3C,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,QAAQ,CAAC;AAClB,CAAC;AAPD,8CAOC;AAOD,2BAAkC,QAAsB;IACtD,aAAa,CAAC,QAAQ,CAAC,CAAC;IAExB,IAAI,kBAAkB,CAAC;IAEvB,GAAG,CAAC,CAAmB,UAAoB,EAApB,KAAA,QAAQ,CAAC,WAAW,EAApB,cAAoB,EAApB,IAAoB;QAAtC,IAAI,UAAU,SAAA;QACjB,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,qBAAqB,CAAC,CAAC,CAAC;YAC9C,IAAM,SAAS,GAAI,UAAsC,CAAC,SAAS,CAAC;YACpE,EAAE,CAAC,CAAC,SAAS,KAAK,OAAO,IAAI,SAAS,KAAK,UAAU,IAAI,SAAS,KAAK,cAAc,CAAC,CAAC,CAAC;gBACtF,MAAM,CAAC,UAAqC,CAAC;YAC/C,CAAC;QACH,CAAC;QACD,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;YAGpE,kBAAkB,GAAG,UAAoC,CAAC;QAC5D,CAAC;KACF;IAED,EAAE,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;QACvB,MAAM,CAAC,kBAAkB,CAAC;IAC5B,CAAC;IAED,MAAM,IAAI,KAAK,CAAC,sFAAsF,CAAC,CAAC;AAC1G,CAAC;AAxBD,8CAwBC","sourcesContent":["import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\n// Checks the document for errors and throws an exception if there is an error.\nfunction checkDocument(doc: DocumentNode) {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  const numOpDefinitions = doc.definitions.filter((definition) => {\n    return definition.kind === 'OperationDefinition';\n  }).length;\n\n  // can't have more than one operation definition per query\n  if (numOpDefinitions > 1) {\n    throw new Error('Queries must have exactly one operation definition.');\n  }\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(doc: DocumentNode): FragmentDefinitionNode[] {\n  let fragmentDefinitions: FragmentDefinitionNode[] = doc.definitions.filter((definition) => {\n    if (definition.kind === 'FragmentDefinition') {\n      return true;\n    } else {\n      return false;\n    }\n  }) as FragmentDefinitionNode[];\n\n  return fragmentDefinitions;\n}\n\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(fragments: FragmentDefinitionNode[] = []): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach((fragment) => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(queryDoc: DocumentNode): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\n"]}},"error":null,"hash":"cc3311c8da28cb9a552e5d11a803981a","cacheData":{"env":{}}}